"""
Python Zaman Dilimi ƒ∞≈ülemleri ve Senkronizasyon

Bu dosya Python'da zaman dilimi y√∂netimi, d√ºnya saatleri,
zaman senkronizasyonu ve ileri seviye timezone i≈ülemlerini kapsar.
Global uygulamalar i√ßin kritik zaman y√∂netimi tekniklerini √∂ƒüreneceƒüiz.
"""

import datetime
from dateutil import tz
import pytz
import time
import threading
from concurrent.futures import ThreadPoolExecutor
import json
from collections import defaultdict

# =============================================================================
# 1. ZAMAN Dƒ∞Lƒ∞Mƒ∞ TEMELLERƒ∞ VE Y√ñNETIM
# =============================================================================

print("=== Zaman Dilimi Temelleri ve Y√∂netim ===")

def zaman_dilimi_temelleri():
    """Zaman dilimi temelleri ve y√∂netim"""
    
    print("üåç Zaman Dilimi Temelleri:")
    
    # UTC temel zaman
    utc_now = datetime.datetime.utcnow()
    print(f"UTC Zaman: {utc_now}")
    
    # Yerel zaman
    local_now = datetime.datetime.now()
    print(f"Yerel Zaman: {local_now}")
    
    # Timezone aware UTC
    utc_aware = datetime.datetime.now(pytz.UTC)
    print(f"UTC (timezone aware): {utc_aware}")
    
    # Sistem timezone'u
    system_tz = tz.tzlocal()
    system_time = datetime.datetime.now(system_tz)
    print(f"Sistem timezone: {system_time}")
    
    print(f"\nüïê D√ºnya Zaman Dilimleri:")
    
    # Major zaman dilimleri
    major_timezones = [
        ('UTC', 'UTC'),
        ('US/Eastern', 'New York'),
        ('US/Pacific', 'Los Angeles'),
        ('Europe/London', 'Londra'),
        ('Europe/Paris', 'Paris'),
        ('Europe/Istanbul', 'ƒ∞stanbul'),
        ('Asia/Tokyo', 'Tokyo'),
        ('Asia/Shanghai', '≈ûangay'),
        ('Asia/Dubai', 'Dubai'),
        ('Australia/Sydney', 'Sidney'),
        ('Pacific/Auckland', 'Auckland')
    ]
    
    base_time = datetime.datetime(2024, 6, 15, 12, 0, 0, tzinfo=pytz.UTC)
    
    print("Aynƒ± anda d√ºnya saatleri (UTC 12:00):")
    for tz_name, city in major_timezones:
        tz = pytz.timezone(tz_name)
        local_time = base_time.astimezone(tz)
        offset = local_time.strftime('%z')
        print(f"{city:12}: {local_time.strftime('%H:%M (%d.%m.%Y)')} (UTC{offset[:3]}:{offset[3:]})")
    
    print(f"\nüîÑ Timezone D√∂n√º≈ü√ºmleri:")
    
    # ƒ∞stanbul zamanƒ±ndan diƒüer ≈üehirlere
    istanbul_tz = pytz.timezone('Europe/Istanbul')
    istanbul_time = istanbul_tz.localize(datetime.datetime(2024, 6, 15, 15, 30, 0))
    
    print(f"ƒ∞stanbul Zamanƒ±: {istanbul_time.strftime('%H:%M (%d.%m.%Y %Z)')}")
    
    conversion_cities = [
        ('America/New_York', 'New York'),
        ('America/Los_Angeles', 'Los Angeles'),
        ('Europe/London', 'Londra'),
        ('Asia/Tokyo', 'Tokyo'),
        ('Australia/Sydney', 'Sidney')
    ]
    
    for tz_name, city in conversion_cities:
        tz = pytz.timezone(tz_name)
        converted = istanbul_time.astimezone(tz)
        print(f"{city:15}: {converted.strftime('%H:%M (%d.%m.%Y %Z)')}")
    
    print(f"\nüìä Timezone Bilgileri:")
    
    def timezone_info(tz_name):
        """Timezone hakkƒ±nda detaylƒ± bilgi"""
        tz = pytz.timezone(tz_name)
        now = datetime.datetime.now(tz)
        
        # DST bilgisi
        dst_offset = now.dst()
        is_dst = dst_offset.total_seconds() != 0
        
        # UTC offset
        utc_offset = now.utcoffset()
        offset_hours = utc_offset.total_seconds() / 3600
        
        return {
            'timezone': tz_name,
            'current_time': now,
            'utc_offset': offset_hours,
            'is_dst': is_dst,
            'dst_offset': dst_offset.total_seconds() / 3600 if dst_offset else 0,
            'tzname': now.tzname()
        }
    
    # √ñnemli timezone'lar hakkƒ±nda bilgi
    important_zones = ['Europe/Istanbul', 'US/Eastern', 'US/Pacific', 'Asia/Tokyo']
    
    for zone in important_zones:
        info = timezone_info(zone)
        dst_status = "‚úÖ DST" if info['is_dst'] else "‚ùå No DST"
        print(f"{zone:20}: UTC{info['utc_offset']:+.1f} {dst_status} ({info['tzname']})")

zaman_dilimi_temelleri()

# =============================================================================
# 2. DAYLIGHT SAVING TIME (DST) Y√ñNETƒ∞Mƒ∞
# =============================================================================

print("\n=== Daylight Saving Time (DST) Y√∂netimi ===")

def dst_yonetimi():
    """DST ge√ßi≈üleri ve y√∂netimi"""
    
    print("üîÑ DST Ge√ßi≈üleri ve Analizi:")
    
    def dst_gecisleri_bul(timezone_name, yil):
        """Belirtilen yƒ±l i√ßin DST ge√ßi≈ülerini bul"""
        tz = pytz.timezone(timezone_name)
        
        # Yƒ±l boyunca DST ge√ßi≈ülerini ara
        gecisler = []
        
        for ay in range(1, 13):
            for gun in range(1, 32):
                try:
                    # Her g√ºn√º kontrol et
                    tarih = datetime.datetime(yil, ay, gun, 12, 0, 0)
                    localized = tz.localize(tarih, is_dst=None)
                    
                    # √ñnceki g√ºnle kar≈üƒ±la≈ütƒ±r
                    if gun > 1:
                        onceki_tarih = datetime.datetime(yil, ay, gun-1, 12, 0, 0)
                        onceki_localized = tz.localize(onceki_tarih, is_dst=None)
                        
                        if localized.dst() != onceki_localized.dst():
                            gecis_turu = "Yaz saati ba≈ülangƒ±cƒ±" if localized.dst() > onceki_localized.dst() else "Yaz saati biti≈üi"
                            gecisler.append({
                                'tarih': tarih.date(),
                                'turu': gecis_turu,
                                'onceki_dst': onceki_localized.dst(),
                                'yeni_dst': localized.dst()
                            })
                
                except (ValueError, pytz.AmbiguousTimeError, pytz.NonExistentTimeError):
                    continue
        
        return gecisler
    
    # DST kullanan timezone'lar
    dst_zones = ['US/Eastern', 'Europe/London', 'Europe/Paris']
    
    for zone in dst_zones:
        print(f"\n{zone} DST Ge√ßi≈üleri (2024):")
        gecisler = dst_gecisleri_bul(zone, 2024)
        
        for gecis in gecisler:
            print(f"  {gecis['tarih']}: {gecis['turu']}")
    
    print(f"\n‚ö†Ô∏è DST Sorunlarƒ± ve √á√∂z√ºmleri:")
    
    def dst_sorunlari_demo():
        """DST ge√ßi≈ülerinde ya≈üanan sorunlarƒ± g√∂ster"""
        
        # US Eastern timezone'da DST ge√ßi≈üi
        eastern = pytz.timezone('US/Eastern')
        
        # Yaz saati ba≈ülangƒ±cƒ± (2024 Mart ikinci pazar)
        # 2:00 AM -> 3:00 AM (1 saat ileri)
        print("Yaz Saati Ba≈ülangƒ±cƒ± Problemi:")
        
        try:
            # 2:30 AM - bu saat mevcut deƒüil!
            non_existent = eastern.localize(datetime.datetime(2024, 3, 10, 2, 30, 0))
        except pytz.NonExistentTimeError as e:
            print(f"  ‚ùå Hata: {e}")
        
        # G√ºvenli y√∂ntem
        safe_time = eastern.localize(datetime.datetime(2024, 3, 10, 2, 30, 0), is_dst=False)
        print(f"  ‚úÖ G√ºvenli: {safe_time} (is_dst=False kullanarak)")
        
        # Yaz saati biti≈üi (2024 Kasƒ±m ilk pazar)
        # 2:00 AM -> 1:00 AM (1 saat geri)
        print("\nYaz Saati Biti≈üi Problemi:")
        
        try:
            # 1:30 AM - bu saat iki kez ya≈üanƒ±r!
            ambiguous = eastern.localize(datetime.datetime(2024, 11, 3, 1, 30, 0))
        except pytz.AmbiguousTimeError as e:
            print(f"  ‚ö†Ô∏è Belirsizlik: {e}")
        
        # Her iki durumu da g√∂ster
        first_occurrence = eastern.localize(datetime.datetime(2024, 11, 3, 1, 30, 0), is_dst=True)
        second_occurrence = eastern.localize(datetime.datetime(2024, 11, 3, 1, 30, 0), is_dst=False)
        
        print(f"  ‚úÖ ƒ∞lk ge√ßi≈ü: {first_occurrence} (DST=True)")
        print(f"  ‚úÖ ƒ∞kinci ge√ßi≈ü: {second_occurrence} (DST=False)")
    
    dst_sorunlari_demo()
    
    print(f"\nüõ°Ô∏è DST G√ºvenli Programlama:")
    
    class DSTGuvenliZaman:
        """DST g√ºvenli zaman i≈ülemleri"""
        
        @staticmethod
        def guvenli_localize(tz, dt, prefer_dst=True):
            """DST g√ºvenli localization"""
            try:
                return tz.localize(dt)
            except pytz.NonExistentTimeError:
                # Var olmayan saat - is_dst kullan
                return tz.localize(dt, is_dst=prefer_dst)
            except pytz.AmbiguousTimeError:
                # Belirsiz saat - tercihe g√∂re √ß√∂z
                return tz.localize(dt, is_dst=prefer_dst)
        
        @staticmethod
        def zaman_araliƒüi_hesapla(baslangic, bitis, timezone_name):
            """DST ge√ßi≈ülerini dikkate alarak zaman aralƒ±ƒüƒ± hesapla"""
            tz = pytz.timezone(timezone_name)
            
            # Eƒüer naive datetime ise localize et
            if baslangic.tzinfo is None:
                baslangic = DSTGuvenliZaman.guvenli_localize(tz, baslangic)
            if bitis.tzinfo is None:
                bitis = DSTGuvenliZaman.guvenli_localize(tz, bitis)
            
            # UTC'ye √ßevir ve farkƒ± hesapla
            baslangic_utc = baslangic.astimezone(pytz.UTC)
            bitis_utc = bitis.astimezone(pytz.UTC)
            
            return bitis_utc - baslangic_utc
        
        @staticmethod
        def is_saatleri_hesapla(tarih, timezone_name, baslangic_saat=9, bitis_saat=17):
            """DST dikkate alarak i≈ü saatlerini hesapla"""
            tz = pytz.timezone(timezone_name)
            
            # ƒ∞≈ü g√ºn√º ba≈ülangƒ±√ß ve biti≈üi
            is_baslangic = DSTGuvenliZaman.guvenli_localize(
                tz, 
                datetime.datetime.combine(tarih, datetime.time(baslangic_saat, 0))
            )
            is_bitis = DSTGuvenliZaman.guvenli_localize(
                tz,
                datetime.datetime.combine(tarih, datetime.time(bitis_saat, 0))
            )
            
            # Ger√ßek i≈ü saati hesapla
            sure = DSTGuvenliZaman.zaman_araliƒüi_hesapla(is_baslangic, is_bitis, timezone_name)
            
            return {
                'baslangic': is_baslangic,
                'bitis': is_bitis,
                'sure_saat': sure.total_seconds() / 3600,
                'sure_dakika': sure.total_seconds() / 60
            }
    
    # DST g√ºvenli i≈ülem √∂rnekleri
    test_tarihi = datetime.date(2024, 3, 10)  # DST ge√ßi≈ü g√ºn√º
    normal_tarihi = datetime.date(2024, 6, 15)  # Normal g√ºn
    
    print("DST G√ºvenli ƒ∞≈ü Saati Hesaplamalarƒ±:")
    
    for tarih, aciklama in [(test_tarihi, "DST Ge√ßi≈ü G√ºn√º"), (normal_tarihi, "Normal G√ºn")]:
        is_saati = DSTGuvenliZaman.is_saatleri_hesapla(tarih, 'US/Eastern')
        print(f"\n{aciklama} ({tarih}):")
        print(f"  Ba≈ülangƒ±√ß: {is_saati['baslangic'].strftime('%H:%M %Z')}")
        print(f"  Biti≈ü: {is_saati['bitis'].strftime('%H:%M %Z')}")
        print(f"  S√ºre: {is_saati['sure_saat']:.1f} saat")

dst_yonetimi()

# =============================================================================
# 3. GLOBAL UYGULAMA ZAMAN Y√ñNETƒ∞Mƒ∞
# =============================================================================

print("\n=== Global Uygulama Zaman Y√∂netimi ===")

def global_zaman_yonetimi():
    """Global uygulamalar i√ßin zaman y√∂netimi"""
    
    print("üåê Global Zaman Y√∂netimi:")
    
    class GlobalZamanYoneticisi:
        """Global uygulamalar i√ßin zaman y√∂neticisi"""
        
        def __init__(self, default_timezone='UTC'):
            self.default_tz = pytz.timezone(default_timezone)
            self.user_timezones = {}
            self.server_timezone = 'UTC'
        
        def kullanici_timezone_ayarla(self, user_id, timezone_name):
            """Kullanƒ±cƒ± timezone'unu ayarla"""
            try:
                tz = pytz.timezone(timezone_name)
                self.user_timezones[user_id] = tz
                return True, f"Timezone {timezone_name} olarak ayarlandƒ±"
            except pytz.UnknownTimeZoneError:
                return False, f"Bilinmeyen timezone: {timezone_name}"
        
        def utc_kaydet(self, dt=None):
            """Veritabanƒ±na kayƒ±t i√ßin UTC zaman"""
            if dt is None:
                dt = datetime.datetime.utcnow()
            
            if dt.tzinfo is None:
                dt = pytz.UTC.localize(dt)
            
            return dt.astimezone(pytz.UTC)
        
        def kullanici_zamani_goster(self, user_id, utc_time):
            """UTC zamanƒ± kullanƒ±cƒ±nƒ±n timezone'unda g√∂ster"""
            user_tz = self.user_timezones.get(user_id, self.default_tz)
            
            if utc_time.tzinfo is None:
                utc_time = pytz.UTC.localize(utc_time)
            
            return utc_time.astimezone(user_tz)
        
        def toplanti_zamani_koordine_et(self, user_ids, utc_time):
            """√áoklu kullanƒ±cƒ± i√ßin toplantƒ± zamanƒ±nƒ± g√∂ster"""
            koordinasyon = {}
            
            for user_id in user_ids:
                local_time = self.kullanici_zamani_goster(user_id, utc_time)
                koordinasyon[user_id] = {
                    'local_time': local_time,
                    'timezone': str(local_time.tzinfo),
                    'is_business_hours': self.is_saati_mi(local_time)
                }
            
            return koordinasyon
        
        def is_saati_mi(self, dt):
            """Belirtilen zaman i≈ü saati mi?"""
            # Hafta sonu kontrol√º
            if dt.weekday() >= 5:
                return False
            
            # Saat kontrol√º (09:00-17:00)
            return 9 <= dt.hour < 17
        
        def en_iyi_toplanti_zamani_bul(self, user_ids, tarih, sure_saat=1):
            """T√ºm kullanƒ±cƒ±lar i√ßin en uygun toplantƒ± zamanƒ±nƒ± bul"""
            # Tarih ba≈ülangƒ±cƒ± UTC'de
            utc_baslangic = datetime.datetime.combine(
                tarih, datetime.time(0, 0), tzinfo=pytz.UTC
            )
            
            uygun_saatler = []
            
            # Her saati kontrol et
            for saat in range(24):
                test_zamani = utc_baslangic + datetime.timedelta(hours=saat)
                koordinasyon = self.toplanti_zamani_koordine_et(user_ids, test_zamani)
                
                # T√ºm kullanƒ±cƒ±lar i≈ü saatinde mi?
                tumunu_uygun = all(
                    info['is_business_hours'] 
                    for info in koordinasyon.values()
                )
                
                if tumunu_uygun:
                    uygun_saatler.append({
                        'utc_time': test_zamani,
                        'koordinasyon': koordinasyon
                    })
            
            return uygun_saatler
    
    # Global zaman y√∂neticisi test
    gzm = GlobalZamanYoneticisi()
    
    # Kullanƒ±cƒ±larƒ± kaydet
    users = [
        ('user1', 'Europe/Istanbul'),
        ('user2', 'US/Eastern'),
        ('user3', 'Asia/Tokyo'),
        ('user4', 'Australia/Sydney')
    ]
    
    for user_id, tz_name in users:
        success, message = gzm.kullanici_timezone_ayarla(user_id, tz_name)
        print(f"{user_id}: {message}")
    
    # Toplantƒ± zamanƒ± koordinasyonu
    print(f"\nüìÖ Toplantƒ± Zamanƒ± Koordinasyonu:")
    
    utc_meeting = datetime.datetime(2024, 6, 15, 14, 0, tzinfo=pytz.UTC)  # UTC 14:00
    koordinasyon = gzm.toplanti_zamani_koordine_et(['user1', 'user2', 'user3', 'user4'], utc_meeting)
    
    print(f"UTC Toplantƒ± Zamanƒ±: {utc_meeting.strftime('%Y-%m-%d %H:%M UTC')}")
    
    for user_id, info in koordinasyon.items():
        status = "‚úÖ ƒ∞≈ü Saati" if info['is_business_hours'] else "‚ùå ƒ∞≈ü Dƒ±≈üƒ±"
        print(f"{user_id}: {info['local_time'].strftime('%H:%M (%d.%m.%Y)')} {status}")
    
    # En uygun toplantƒ± zamanlarƒ±
    print(f"\nüéØ En Uygun Toplantƒ± Zamanlarƒ±:")
    
    uygun_zamanlar = gzm.en_iyi_toplanti_zamani_bul(
        ['user1', 'user2', 'user3', 'user4'], 
        datetime.date(2024, 6, 17)  # Pazartesi
    )
    
    if uygun_zamanlar:
        print("T√ºm kullanƒ±cƒ±lar i√ßin uygun saatler:")
        for uygun in uygun_zamanlar[:3]:  # ƒ∞lk 3'√º g√∂ster
            utc_time = uygun['utc_time']
            print(f"\nUTC {utc_time.strftime('%H:%M')}:")
            for user_id, info in uygun['koordinasyon'].items():
                print(f"  {user_id}: {info['local_time'].strftime('%H:%M')}")
    else:
        print("T√ºm kullanƒ±cƒ±lar i√ßin uygun zaman bulunamadƒ±.")
    
    print(f"\nüìä Zaman Dilimi √áakƒ±≈üma Analizi:")
    
    def cakisma_analizi(timezone_pairs):
        """ƒ∞ki timezone arasƒ± √ßakƒ±≈üma analizi"""
        cakismalar = []
        
        for tz1_name, tz2_name in timezone_pairs:
            tz1 = pytz.timezone(tz1_name)
            tz2 = pytz.timezone(tz2_name)
            
            # ƒ∞≈ü saati √ßakƒ±≈ümasƒ±nƒ± hesapla
            base_date = datetime.date(2024, 6, 17)  # Pazartesi
            
            cakisan_saatler = []
            
            for saat in range(24):
                # Birinci timezone'da i≈ü saati mi?
                dt1 = datetime.datetime.combine(base_date, datetime.time(saat, 0))
                dt1_local = tz1.localize(dt1)
                
                # ƒ∞kinci timezone'da kar≈üƒ±lƒ±k gelen saat
                dt2_utc = dt1_local.astimezone(pytz.UTC)
                dt2_local = dt2_utc.astimezone(tz2)
                
                # Her ikisi de i≈ü saatinde mi?
                if (9 <= dt1_local.hour < 17 and dt1_local.weekday() < 5 and
                    9 <= dt2_local.hour < 17 and dt2_local.weekday() < 5):
                    cakisan_saatler.append({
                        'tz1_saat': dt1_local.strftime('%H:%M'),
                        'tz2_saat': dt2_local.strftime('%H:%M')
                    })
            
            cakismalar.append({
                'tz1': tz1_name,
                'tz2': tz2_name,
                'cakisan_saatler': cakisan_saatler
            })
        
        return cakismalar
    
    # √ñnemli timezone √ßiftleri
    timezone_pairs = [
        ('Europe/Istanbul', 'US/Eastern'),
        ('Asia/Tokyo', 'US/Pacific'),
        ('Europe/London', 'Asia/Shanghai')
    ]
    
    cakisma_sonuclari = cakisma_analizi(timezone_pairs)
    
    for sonuc in cakisma_sonuclari:
        print(f"\n{sonuc['tz1']} ‚Üî {sonuc['tz2']}:")
        if sonuc['cakisan_saatler']:
            print(f"  √áakƒ±≈üan i≈ü saatleri ({len(sonuc['cakisan_saatler'])} saat):")
            for cakisma in sonuc['cakisan_saatler'][:5]:  # ƒ∞lk 5'i g√∂ster
                print(f"    {cakisma['tz1_saat']} ‚Üî {cakisma['tz2_saat']}")
        else:
            print("  ƒ∞≈ü saati √ßakƒ±≈ümasƒ± yok")

global_zaman_yonetimi()

# =============================================================================
# 4. ZAMAN SENKRONIZASYONU VE NTP
# =============================================================================

print("\n=== Zaman Senkronizasyonu ve NTP ===")

def zaman_senkronizasyonu():
    """Zaman senkronizasyonu ve NTP i≈ülemleri"""
    
    print("‚è∞ Zaman Senkronizasyonu:")
    
    class ZamanSenkronizatoru:
        """Zaman senkronizasyon ara√ßlarƒ±"""
        
        def __init__(self):
            self.referans_sunucular = [
                'time.google.com',
                'pool.ntp.org', 
                'time.cloudflare.com'
            ]
            self.son_senkronizasyon = None
            self.offset = 0  # Yerel saatle fark (saniye)
        
        def sistem_zamani_al(self):
            """Sistem zamanƒ± al"""
            return datetime.datetime.now()
        
        def utc_zamani_al(self):
            """UTC zamanƒ± al"""
            return datetime.datetime.utcnow()
        
        def zaman_farki_hesapla(self, zaman1, zaman2):
            """ƒ∞ki zaman arasƒ±ndaki farkƒ± hesapla"""
            if isinstance(zaman1, str):
                zaman1 = datetime.datetime.fromisoformat(zaman1)
            if isinstance(zaman2, str):
                zaman2 = datetime.datetime.fromisoformat(zaman2)
            
            return abs((zaman1 - zaman2).total_seconds())
        
        def zaman_drift_tespit_et(self, referans_zaman):
            """Zaman kaymasƒ± tespit et"""
            sistem_zamani = self.sistem_zamani_al()
            fark = self.zaman_farki_hesapla(sistem_zamani, referans_zaman)
            
            # 1 saniyeden fazla fark varsa drift var
            if fark > 1.0:
                return True, fark
            return False, fark
        
        def senkronizasyon_gerekli_mi(self, max_drift_saniye=30):
            """Senkronizasyon gerekli mi kontrol et"""
            if self.son_senkronizasyon is None:
                return True, "ƒ∞lk senkronizasyon"
            
            # Son senkronizasyondan ne kadar zaman ge√ßti?
            gecen_sure = (datetime.datetime.now() - self.son_senkronizasyon).total_seconds()
            
            if gecen_sure > 3600:  # 1 saat
                return True, f"Son senkronizasyon: {gecen_sure/3600:.1f} saat √∂nce"
            
            return False, f"Son senkronizasyon: {gecen_sure/60:.1f} dakika √∂nce"
        
        def mock_ntp_sorgula(self):
            """Mock NTP sorgusu (ger√ßek NTP sim√ºlasyonu)"""
            # Ger√ßek uygulamada ntplib kullanƒ±lƒ±r
            import random
            
            # Sim√ºle edilmi≈ü NTP yanƒ±tƒ±
            simdi = datetime.datetime.utcnow()
            # K√º√ß√ºk bir rastgele offset ekle
            offset = random.uniform(-0.1, 0.1)  # ¬±100ms
            
            return {
                'server_time': simdi + datetime.timedelta(seconds=offset),
                'offset': offset,
                'delay': random.uniform(0.01, 0.05),  # Network delay
                'success': True
            }
        
        def senkronizasyon_yap(self):
            """Zaman senkronizasyonu yap"""
            print("Zaman senkronizasyonu ba≈ülatƒ±lƒ±yor...")
            
            basarili_sorgular = []
            
            for server in self.referans_sunucular:
                try:
                    # Mock NTP sorgusu
                    ntp_response = self.mock_ntp_sorgula()
                    
                    if ntp_response['success']:
                        basarili_sorgular.append(ntp_response)
                        print(f"  ‚úÖ {server}: offset {ntp_response['offset']:+.3f}s")
                    
                except Exception as e:
                    print(f"  ‚ùå {server}: {e}")
            
            if basarili_sorgular:
                # Ortalama offset hesapla
                ortalama_offset = sum(s['offset'] for s in basarili_sorgular) / len(basarili_sorgular)
                self.offset = ortalama_offset
                self.son_senkronizasyon = datetime.datetime.now()
                
                return True, f"Senkronizasyon ba≈üarƒ±lƒ±. Offset: {ortalama_offset:+.3f}s"
            else:
                return False, "T√ºm sunucular ba≈üarƒ±sƒ±z"
        
        def duzeltilmis_zaman(self):
            """Offset ile d√ºzeltilmi≈ü sistem zamanƒ±"""
            return datetime.datetime.now() + datetime.timedelta(seconds=self.offset)
    
    # Zaman senkronizatoru test
    senkronizator = ZamanSenkronizatoru()
    
    # ƒ∞lk durum kontrol√º
    gerekli, neden = senkronizator.senkronizasyon_gerekli_mi()
    print(f"Senkronizasyon gerekli: {gerekli} - {neden}")
    
    # Senkronizasyon yap
    basarili, mesaj = senkronizator.senkronizasyon_yap()
    print(f"Senkronizasyon sonucu: {mesaj}")
    
    # D√ºzeltilmi≈ü zamanƒ± g√∂ster
    sistem_zamani = senkronizator.sistem_zamani_al()
    duzeltilmis = senkronizator.duzeltilmis_zaman()
    
    print(f"\nSistem zamanƒ±: {sistem_zamani}")
    print(f"D√ºzeltilmi≈ü zaman: {duzeltilmis}")
    print(f"Fark: {(duzeltilmis - sistem_zamani).total_seconds():.3f} saniye")
    
    print(f"\nüìä Zaman Doƒüruluƒüu Monitoring:")
    
    class ZamanDogrlukMonitor:
        """Zaman doƒüruluƒüu izleme"""
        
        def __init__(self):
            self.olcumler = []
            self.uyari_esigi = 1.0  # saniye
            self.kritik_esigi = 5.0  # saniye
        
        def olcum_ekle(self, sistem_zamani, referans_zamani, kaynak="NTP"):
            """Yeni √∂l√ß√ºm ekle"""
            if isinstance(sistem_zamani, str):
                sistem_zamani = datetime.datetime.fromisoformat(sistem_zamani)
            if isinstance(referans_zamani, str):
                referans_zamani = datetime.datetime.fromisoformat(referans_zamani)
            
            fark = (sistem_zamani - referans_zamani).total_seconds()
            
            olcum = {
                'zaman': datetime.datetime.now(),
                'sistem_zamani': sistem_zamani,
                'referans_zamani': referans_zamani,
                'fark': fark,
                'kaynak': kaynak
            }
            
            self.olcumler.append(olcum)
            
            # Eski √∂l√ß√ºmleri temizle (son 100 √∂l√ß√ºm)
            if len(self.olcumler) > 100:
                self.olcumler = self.olcumler[-100:]
            
            return self.durum_analizi(olcum)
        
        def durum_analizi(self, olcum):
            """Durum analizi yap"""
            fark = abs(olcum['fark'])
            
            if fark > self.kritik_esigi:
                return "üî¥ KRƒ∞Tƒ∞K", f"Zaman farkƒ± {fark:.2f}s (>{self.kritik_esigi}s)"
            elif fark > self.uyari_esigi:
                return "üü° UYARI", f"Zaman farkƒ± {fark:.2f}s (>{self.uyari_esigi}s)"
            else:
                return "üü¢ NORMAL", f"Zaman farkƒ± {fark:.3f}s"
        
        def istatistikler(self):
            """ƒ∞statistiksel analiz"""
            if not self.olcumler:
                return "√ñl√ß√ºm yok"
            
            farklar = [abs(o['fark']) for o in self.olcumler]
            
            return {
                'toplam_olcum': len(self.olcumler),
                'ortalama_fark': sum(farklar) / len(farklar),
                'max_fark': max(farklar),
                'min_fark': min(farklar),
                'son_olcum': self.olcumler[-1]['zaman']
            }
    
    # Monitoring test
    monitor = ZamanDogrlukMonitor()
    
    # Sim√ºle edilmi≈ü √∂l√ß√ºmler
    import random
    for i in range(10):
        sistem = datetime.datetime.now()
        # Rastgele offset ekle
        offset = random.uniform(-0.5, 2.0)
        referans = sistem + datetime.timedelta(seconds=offset)
        
        durum, mesaj = monitor.olcum_ekle(sistem, referans)
        print(f"√ñl√ß√ºm {i+1:2d}: {durum} - {mesaj}")
        
        time.sleep(0.1)  # Kƒ±sa bekleme
    
    # ƒ∞statistikler
    stats = monitor.istatistikler()
    print(f"\nüìà Monitoring ƒ∞statistikleri:")
    print(f"Toplam √∂l√ß√ºm: {stats['toplam_olcum']}")
    print(f"Ortalama fark: {stats['ortalama_fark']:.3f}s")
    print(f"Maksimum fark: {stats['max_fark']:.3f}s")
    print(f"Minimum fark: {stats['min_fark']:.3f}s")

zaman_senkronizasyonu()

# =============================================================================
# 5. √áOKLU THREAD VE ZAMAN Y√ñNETƒ∞Mƒ∞
# =============================================================================

print("\n=== √áoklu Thread ve Zaman Y√∂netimi ===")

def coklu_thread_zaman():
    """√áoklu thread ortamƒ±nda zaman y√∂netimi"""
    
    print("üßµ √áoklu Thread Zaman Y√∂netimi:")
    
    class ThreadSafeZamanYoneticisi:
        """Thread-safe zaman y√∂neticisi"""
        
        def __init__(self):
            self._lock = threading.Lock()
            self.thread_zamanlari = {}
            self.global_baslangic = time.time()
        
        def thread_zaman_kaydet(self, thread_id=None):
            """Thread zamanƒ±nƒ± kaydet"""
            if thread_id is None:
                thread_id = threading.current_thread().ident
            
            with self._lock:
                self.thread_zamanlari[thread_id] = {
                    'baslangic': time.time(),
                    'islem_sayisi': 0,
                    'toplam_sure': 0
                }
        
        def islem_baslat(self, thread_id=None):
            """ƒ∞≈ülem ba≈ülat"""
            if thread_id is None:
                thread_id = threading.current_thread().ident
            
            return time.perf_counter()
        
        def islem_bitir(self, baslangic_zamani, thread_id=None):
            """ƒ∞≈ülem bitir ve s√ºreyi kaydet"""
            if thread_id is None:
                thread_id = threading.current_thread().ident
            
            sure = time.perf_counter() - baslangic_zamani
            
            with self._lock:
                if thread_id in self.thread_zamanlari:
                    self.thread_zamanlari[thread_id]['islem_sayisi'] += 1
                    self.thread_zamanlari[thread_id]['toplam_sure'] += sure
            
            return sure
        
        def thread_istatistikleri(self):
            """Thread istatistikleri"""
            with self._lock:
                return dict(self.thread_zamanlari)
    
    # Thread-safe zaman y√∂neticisi test
    zaman_yoneticisi = ThreadSafeZamanYoneticisi()
    
    def worker_function(worker_id, islem_sayisi):
        """Worker thread fonksiyonu"""
        thread_id = threading.current_thread().ident
        zaman_yoneticisi.thread_zaman_kaydet(thread_id)
        
        print(f"Worker {worker_id} ba≈üladƒ± (Thread ID: {thread_id})")
        
        for i in range(islem_sayisi):
            # ƒ∞≈ülem sim√ºlasyonu
            baslangic = zaman_yoneticisi.islem_baslat(thread_id)
            
            # Rastgele s√ºre bekle
            import random
            time.sleep(random.uniform(0.1, 0.5))
            
            sure = zaman_yoneticisi.islem_bitir(baslangic, thread_id)
            
            if i % 2 == 0:  # Her 2 i≈ülemde bir rapor
                print(f"  Worker {worker_id} - ƒ∞≈ülem {i+1}: {sure:.3f}s")
        
        print(f"Worker {worker_id} tamamlandƒ±")
    
    # √áoklu thread test
    print("√áoklu thread performans testi ba≈ülatƒ±lƒ±yor...")
    
    with ThreadPoolExecutor(max_workers=3) as executor:
        futures = []
        
        # 3 worker ba≈ülat
        for i in range(3):
            future = executor.submit(worker_function, i+1, 3)
            futures.append(future)
        
        # T√ºm thread'lerin bitmesini bekle
        for future in futures:
            future.result()
    
    # ƒ∞statistikleri g√∂ster
    print(f"\nüìä Thread ƒ∞statistikleri:")
    stats = zaman_yoneticisi.thread_istatistikleri()
    
    for thread_id, stat in stats.items():
        ortalama = stat['toplam_sure'] / stat['islem_sayisi'] if stat['islem_sayisi'] > 0 else 0
        print(f"Thread {thread_id}:")
        print(f"  ƒ∞≈ülem sayƒ±sƒ±: {stat['islem_sayisi']}")
        print(f"  Toplam s√ºre: {stat['toplam_sure']:.3f}s")
        print(f"  Ortalama s√ºre: {ortalama:.3f}s")
    
    print(f"\n‚è±Ô∏è E≈ü Zamanlƒ± Zaman √ñl√ß√ºm√º:")
    
    def es_zamanli_olcum():
        """E≈ü zamanlƒ± zaman √∂l√ß√ºm√º √∂rneƒüi"""
        
        def task_with_timing(task_name, duration):
            """Zamanlƒ± g√∂rev"""
            start_time = time.perf_counter()
            thread_id = threading.current_thread().name
            
            print(f"{task_name} ba≈üladƒ± (Thread: {thread_id})")
            time.sleep(duration)
            
            end_time = time.perf_counter()
            elapsed = end_time - start_time
            
            print(f"{task_name} tamamlandƒ± - S√ºre: {elapsed:.2f}s (Thread: {thread_id})")
            return elapsed
        
        # Farklƒ± s√ºrelerde g√∂revler
        tasks = [
            ("G√∂rev A", 1.0),
            ("G√∂rev B", 1.5),
            ("G√∂rev C", 0.8),
            ("G√∂rev D", 1.2)
        ]
        
        # Seri √ßalƒ±≈ütƒ±rma
        print("Seri √áalƒ±≈ütƒ±rma:")
        seri_baslangic = time.perf_counter()
        
        for task_name, duration in tasks:
            task_with_timing(task_name, duration)
        
        seri_sure = time.perf_counter() - seri_baslangic
        print(f"Seri toplam s√ºre: {seri_sure:.2f}s")
        
        print(f"\nParalel √áalƒ±≈ütƒ±rma:")
        
        # Paralel √ßalƒ±≈ütƒ±rma
        paralel_baslangic = time.perf_counter()
        
        with ThreadPoolExecutor(max_workers=4) as executor:
            futures = [
                executor.submit(task_with_timing, task_name, duration)
                for task_name, duration in tasks
            ]
            
            # T√ºm g√∂revlerin bitmesini bekle
            for future in futures:
                future.result()
        
        paralel_sure = time.perf_counter() - paralel_baslangic
        print(f"Paralel toplam s√ºre: {paralel_sure:.2f}s")
        
        speedup = seri_sure / paralel_sure
        print(f"Hƒ±zlanma oranƒ±: {speedup:.1f}x")
    
    es_zamanli_olcum()

coklu_thread_zaman()

print("\nüí° Zaman Dilimi ve Senkronizasyon ƒ∞pu√ßlarƒ±:")
print("‚úÖ UTC'yi veri saklama i√ßin temel zaman olarak kullanƒ±n")
print("‚úÖ Kullanƒ±cƒ± aray√ºzlerinde yerel zaman g√∂sterin")
print("‚úÖ DST ge√ßi≈ülerini dikkate alƒ±n")
print("‚úÖ Global uygulamalarda timezone-aware datetime kullanƒ±n")
print("‚úÖ NTP ile sistem zamanƒ±nƒ± d√ºzenli senkronize edin")
print("‚úÖ Thread-safe zaman i≈ülemleri yapƒ±n")
print("‚úÖ Zaman farkƒ± hesaplamalarƒ±nda UTC kullanƒ±n")

print("\n‚ö†Ô∏è Dikkat Edilecek Noktalar:")
print("‚Ä¢ DST ge√ßi≈ülerinde NonExistentTime ve AmbiguousTime hatalarƒ±na dikkat edin")
print("‚Ä¢ Farklƒ± sistemler arasƒ± zaman senkronizasyonunu g√∂z √∂n√ºnde bulundurun")
print("‚Ä¢ Network gecikmeleri zaman hesaplamalarƒ±nƒ± etkileyebilir")
print("‚Ä¢ Thread-safe olmayan zaman i≈ülemleri race condition'a neden olabilir")
print("‚Ä¢ Kullanƒ±cƒ± timezone tercihlerini g√ºvenli saklayƒ±n")

print("\n‚úÖ Python zaman dilimi y√∂netimi √∂ƒürenildi!")
print("‚úÖ DST ge√ßi≈üleri ve sorunlarƒ± √∂ƒürenildi!")
print("‚úÖ Global zaman koordinasyonu √∂ƒürenildi!")
print("‚úÖ Zaman senkronizasyonu teknikleri √∂ƒürenildi!")
print("‚úÖ √áoklu thread zaman y√∂netimi √∂ƒürenildi!")